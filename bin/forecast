#!/usr/bin/env ruby

require "yaml/store"

require "slop"
require "chronic"
require "timezone"
require "geocoder"

require "forecaster"

Forecaster.configure do |config|
  config.cache_dir = "/tmp/forecaster"
  config.records = {
    :prate => ":PRATE:surface:",
    :pres  => ":PRES:surface:",
    :rh    => ":RH:2 m above ground:",
    :tmp   => ":TMP:2 m above ground:",
    :ugrd  => ":UGRD:10 m above ground:",
    :vgrd  => ":VGRD:10 m above ground:",
    :tcdc  => ":TCDC:entire atmosphere:"
  }
end

cache_file = File.join(Forecaster.configuration.cache_dir, "forecast.yml")
store = YAML::Store.new(cache_file)

opts = Slop.parse do |opt|
  opt.bool("-v", "--verbose", "enable verbose mode")
  opt.float("--latitude", "latitude in decimal degree")
  opt.float("--longitude", "longitude in decimal degree")
  opt.array("--time", "when", :default => [])
  opt.array("--location", "when", :default => [])
end

key = :time
opts.args.each do |word|
  case word
  when "for"
    key = :time
  when "in"
    key = :location
  else
    opts[key] << word
  end
end

lat = opts[:latitude] || ENV["FORECAST_LATITUDE"]
lon = opts[:longitude] || ENV["FORECAST_LONGITUDE"]
if opts[:location].size > 0
  Geocoder.configure(:timeout => 10)
  store.transaction do
    location = opts[:location].join(" ")
    key = "geocoder:#{location}"
    res = store[key] || store[key] = Geocoder.search(location).first.data
    lat ||= res["geometry"]["location"]["lat"]
    lon ||= res["geometry"]["location"]["lng"]
  end
end
if lat.nil? || lon.nil?
  puts "Usage: forecast for <time> in <location>"
  exit
end

old_tz = ENV["TZ"]
if ENV["GEONAMES_USERNAME"]
  Timezone::Lookup.config(:geonames) do |config|
    config.username = ENV["GEONAMES_USERNAME"]
  end
  store.transaction do
    key = "timezone:#{lat}:#{lon}"
    ENV["TZ"] = store[key] || store[key] = Timezone::lookup(lat, lon).name
  end
end

# There is a new GFS run every 6 hours starting at midnight UTC, and it
# takes approximately 3 to 5 hours before a run is available to download.
#
# So we take current UTC time and deduce the time of the last GFS run by
# calculating `6 * (h / 6)` where `h` is the current hour. Then we use
# the previous run to be safe because this one may not be available.
#
# There is a forecast for every 3 hours after a run. So we use the
# number of hours between the run and now to find the closest forecast
# in the past, and the closest 3 hours from that in the future, and
# we interpolate the value for the current time.

now = Time.now.utc

req = now
acc = 0
t = now - 6 * 3600

if opts[:time].size > 0
  # TODO: Check if arg is a timestamp first
  arg = Chronic.parse(opts[:time].join(" "))
  if arg.nil?
    puts "Error: could not parse time"
    exit
  end
  req = arg.utc

  if req > now
    acc = (req - now).to_i / 3600
  else
    acc = -3
    t = req - 3 * 3600
  end
end

y = t.year
m = t.month
d = t.day
c = 6 * (t.hour / 6) # hour of GFS run (0, 6, 12 or 18)
h = 3 * ((t.hour - c + 6 + acc) / 3)

if opts[:verbose]
  requested_time = req.localtime
  gfs_run_time =(t - (t.hour - c) * 3600 - t.min * 60 - t.sec).localtime
  forecast_time =(t - (t.hour - c - h) * 3600 - t.min * 60 - t.sec).localtime

  puts "Requested time:  #{requested_time}"
  puts "GFS Run time:    #{gfs_run_time}"
  puts "Forecast time:   #{forecast_time}"
  puts
end

ENV["TZ"] = old_tz

forecast = Forecaster::Forecast.new(y, m, d, c, h)

unless forecast.fetched?
  puts "Downloading '#{forecast.url}' ..." if opts[:verbose]
  forecast.fetch
  puts if opts[:verbose]
end

format = "%-15s % 7.1f %s"

pres = forecast.read(:pres, :latitude => lat, :longitude => lon).to_f
puts format % ["Pressure:", pres / 100.0, "hPa"]

tmp = forecast.read(:tmp, :latitude => lat, :longitude => lon).to_f
puts format % ["Temperature:", tmp - 273.15, "°C"]

ugrd = forecast.read(:ugrd, :latitude => lat, :longitude => lon).to_f
vgrd = forecast.read(:vgrd, :latitude => lat, :longitude => lon).to_f
wind_speed = Math.sqrt(ugrd ** 2 + vgrd ** 2)
wind_direction = (270 - Math.atan2(ugrd, vgrd) * 180 / Math::PI) % 360
puts format % ["Wind Speed:", wind_speed, "m/s"]
puts format % ["Wind Direction:", wind_direction, "°"]

prate = forecast.read(:prate, :latitude => lat, :longitude => lon).to_f
puts format % ["Precipitation:", prate * 3600, "mm"]

rh = forecast.read(:rh, :latitude => lat, :longitude => lon).to_f
puts format % ["Humidity:", rh, "%"]

tcdc = forecast.read(:tcdc, :latitude => lat, :longitude => lon).to_f
puts format % ["Cloud Cover:", tcdc, "%"]

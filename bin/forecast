#!/usr/bin/env ruby

require "yaml/store"

require "trollop"
require "chronic"
require "timezone"
require "geocoder"
require "ruby-progressbar"

require "forecaster"

Forecaster.configure do |config|
  config.cache_dir = "/tmp/forecaster"
  config.records = {
    :prate => ":PRATE:surface:",
    :pres  => ":PRES:surface:",
    :rh    => ":RH:2 m above ground:",
    :tmp   => ":TMP:2 m above ground:",
    :ugrd  => ":UGRD:10 m above ground:",
    :vgrd  => ":VGRD:10 m above ground:",
    :tcdc  => ":TCDC:entire atmosphere:"
  }
end

cache_file = File.join(Forecaster.configuration.cache_dir, "forecast.yml")
store = YAML::Store.new(cache_file)


#
# Parse command line options
#

opts = Trollop::options do
  opt :verbose,   "verbose mode"
  opt :latitude,  "latitude in decimal degree",  :type => Float
  opt :longitude, "longitude in decimal degree", :type => Float
  opt :time,      "when",                        :type => String
  opt :location,  "where",                       :type => String
end

cmd_opts = { :time => [], :location => [] }
key = :time
ARGV.each do |word|
  case word
  when "for"
    key = :time
  when "in"
    key = :location
  else
    cmd_opts[key] << word
  end
end
opts[:time] ||= cmd_opts[:time].join(" ")
opts[:location] ||= cmd_opts[:location].join(" ")


#
# Get location
#

def geolocalize(location)
  Geocoder.configure(:timeout => 10)
  res = Geocoder.search(location).first
  [res.latitude, res.longitude] if res
end

# 1. From environment variables
lat = ENV["FORECAST_LATITUDE"]
lon = ENV["FORECAST_LONGITUDE"]

# 2. From `location` option
if opts[:location]
  store.transaction do
    puts "Geolocalizing:   '#{opts[:location]}'" if opts[:verbose]

    key = "geocoder:#{opts[:location]}"
    lat, lon = store[key] ||= geolocalize(opts[:location])

    if opts[:verbose]
      if lat && lon
        puts "Found:           #{lat}, #{lon}\n\n"
      else
        puts "Not found\n\n"
      end
    end
  end
end

# 3. From `latitude` and `longitude` options
if opts[:latitude] && opts[:longitude]
  lat = opts[:latitude]
  lon = opts[:longitude]
end

if lat.nil? || lon.nil?
  puts "Usage: forecast for <time> in <location>"
  exit
end


#
# Get timezone
#

old_tz = ENV["TZ"]
if ENV["GEONAMES_USERNAME"]
  Timezone::Lookup.config(:geonames) do |config|
    config.username = ENV["GEONAMES_USERNAME"]
  end
  store.transaction do
    key = "timezone:#{lat}:#{lon}"
    ENV["TZ"] = store[key] || store[key] = Timezone::lookup(lat, lon).name
  end
end


#
# Get time
#

# There is a new GFS run every 6 hours starting at midnight UTC, and it
# takes approximately 3 to 5 hours before a run is available online.
#
# So we take current time in UTC and deduce the time of the last GFS run
# by calculating `6 * (h / 6)` where `h` is the current hour. Then we use
# the previous run to be safe because this one may not be available.
#
# There is a forecast for every 3 hours after a run. So we use the
# number of hours between the run and now to find the closest forecast
# in the past, and the closest 3 hours from that in the future, and
# we interpolate the value for the current time.
#
# TODO: At the moment we only use the last forecast before the requested
# time, we need to use the next if its closest, or interpolate between the
# two as explained above.

now = Time.now.utc

# TODO: Find better names
req = now
a = 0
t = now - 6 * 3600

if opts[:time]
  # TODO: Check if arg is a timestamp first
  arg = Chronic.parse(opts[:time])
  if arg.nil?
    puts "Error: could not parse time"
    exit
  end
  req = arg.utc

  if req > now
    a = (req - now).to_i / 3600
  else
    a = -3
    t = req - 3 * 3600
  end
end

y = t.year
m = t.month
d = t.day
c = 6 * (t.hour / 6) # hour of GFS run (0, 6, 12 or 18)
h = 3 * ((t.hour - c + 6 + a) / 3) # hour of the forecast (3, 6, 9, ... 384)

if h > 384
  puts "Error: date too far in the future"
  exit
end

if opts[:verbose]
  requested_time = req.localtime
  gfs_run_time =(t - (t.hour - c) * 3600 - t.min * 60 - t.sec).localtime
  forecast_time =(t - (t.hour - c - h) * 3600 - t.min * 60 - t.sec).localtime

  puts "Requested time:  #{requested_time}"
  puts "GFS Run time:    #{gfs_run_time}"
  puts "Forecast time:   #{forecast_time}"
  puts
end


#
# Get forecast
#

forecast = Forecaster::Forecast.new(y, m, d, c, h)

unless forecast.fetched?
  if opts[:verbose]
    puts "Downloading: '#{forecast.url}'"

    puts "Reading IDX file..."
    ranges = forecast.fetch_index

    filesize = ranges.reduce(0) do |acc, range|
      first, last = range.split("-").map(&:to_i)
      acc + last - first
    end
    filesize_in_megabytes = (filesize.to_f / (1 << 20)).round(2)
    puts "Length: #{filesize} (#{filesize_in_megabytes}M)"
    puts

    progressbar = ProgressBar.create(
      :format => "%p%% [%b>%i] %r KB/s %e",
      :rate_scale => lambda { |rate| rate / 1024 }
    )

    progress_block = lambda do |progress, total|
      progressbar.total = total
      progressbar.progress = progress
    end

    forecast.fetch_grib2(ranges, progress_block: progress_block)

    progressbar.finish
    puts
  else
    forecast.fetch # That's a lot easier ^^
  end
end


#
# Print forecast
#

puts "Weather forecast for #{forecast.time.localtime}, #{lat}, #{lon}"
puts

format = "  %-15s % 7.1f %s"

pres = forecast.read(:pres, :latitude => lat, :longitude => lon).to_f
puts format % ["Pressure:", pres / 100.0, "hPa"]

tmp = forecast.read(:tmp, :latitude => lat, :longitude => lon).to_f
puts format % ["Temperature:", tmp - 273.15, "°C"]

ugrd = forecast.read(:ugrd, :latitude => lat, :longitude => lon).to_f
vgrd = forecast.read(:vgrd, :latitude => lat, :longitude => lon).to_f
wind_speed = Math.sqrt(ugrd ** 2 + vgrd ** 2)
wind_direction = (270 - Math.atan2(ugrd, vgrd) * 180 / Math::PI) % 360
puts format % ["Wind Speed:", wind_speed, "m/s"]
puts format % ["Wind Direction:", wind_direction, "°"]

prate = forecast.read(:prate, :latitude => lat, :longitude => lon).to_f
puts format % ["Precipitation:", prate * 3600, "mm"]

rh = forecast.read(:rh, :latitude => lat, :longitude => lon).to_f
puts format % ["Humidity:", rh, "%"]

tcdc = forecast.read(:tcdc, :latitude => lat, :longitude => lon).to_f
puts format % ["Cloud Cover:", tcdc, "%"]


ENV["TZ"] = old_tz
